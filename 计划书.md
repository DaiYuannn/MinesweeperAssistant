# 基于C++的Windows扫雷助手应用设计（VSCode + MSYS2 + CMake）

## 开发环境配置

### 1. 安装必要软件
- 安装MSYS2：从官网下载并安装
- 安装VSCode：从官网下载并安装
- 安装VSCode扩展：C/C++、CMake、CMake Tools

### 2. 配置MSYS2环境
```bash
# 更新包数据库
pacman -Syu

# 安装编译工具链
pacman -S --needed base-devel mingw-w64-x86_64-toolchain

# 安装OpenCV和其他依赖
pacman -S mingw-w64-x86_64-opencv
pacman -S mingw-w64-x86_64-cmake
```

### 3. 项目结构
```
MinesweeperAssistant/
├── CMakeLists.txt
├── src/
│   ├── main.cpp
│   ├── WindowCapture.cpp
│   ├── WindowCapture.h
│   ├── GameAnalyzer.cpp
│   ├── GameAnalyzer.h
│   ├── DisplayWindow.cpp
│   └── DisplayWindow.h
├── resources/
│   └── templates/  # 存储数字模板图像
└── build/
```

## CMake构建配置

### CMakeLists.txt
```cmake
cmake_minimum_required(VERSION 3.20)
project(MinesweeperAssistant)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# 查找OpenCV
find_package(OpenCV REQUIRED)
include_directories(${OpenCV_INCLUDE_DIRS})

# 添加可执行文件
add_executable(MinesweeperAssistant
    src/main.cpp
    src/WindowCapture.cpp
    src/GameAnalyzer.cpp
    src/DisplayWindow.cpp
)

# 链接库
target_link_libraries(MinesweeperAssistant ${OpenCV_LIBS})
target_link_libraries(MinesweeperAssistant user32 gdi32)

# 设置输出目录
set(EXECUTABLE_OUTPUT_PATH ${CMAKE_BINARY_DIR}/bin)
```

## 核心代码实现

### WindowCapture.h
```cpp
#ifndef WINDOW_CAPTURE_H
#define WINDOW_CAPTURE_H

#include <windows.h>
#include <opencv2/opencv.hpp>
#include <atomic>
#include <mutex>

class WindowCapture {
public:
    WindowCapture();
    ~WindowCapture();
    
    HWND SelectGameWindow();
    bool CaptureGameArea(cv::Mat& output);
    bool IdentifyGameBounds(const cv::Mat& screenCapture, cv::Rect& gameRect);
    bool AnalyzeGridLayout(const cv::Mat& gameArea, int& rows, int& cols);
    
    void SetGameWindow(HWND hwnd) { m_gameHwnd = hwnd; }
    HWND GetGameWindow() const { return m_gameHwnd; }
    
private:
    HWND m_gameHwnd;
    cv::Rect m_gameRect;
    int m_rows, m_cols;
    
    static BOOL CALLBACK EnumWindowsProc(HWND hwnd, LPARAM lParam);
    static LRESULT CALLBACK MouseHookProc(int nCode, WPARAM wParam, LPARAM lParam);
};

#endif
```

### WindowCapture.cpp
```cpp
#include "WindowCapture.h"
#include <iostream>
#include <vector>

// 全局变量用于窗口选择
static RECT g_selectionRect;
static bool g_isSelecting = false;
static HHOOK g_mouseHook = NULL;

WindowCapture::WindowCapture() : m_gameHwnd(NULL), m_rows(0), m_cols(0) {}

WindowCapture::~WindowCapture() {
    if (g_mouseHook) {
        UnhookWindowsHookEx(g_mouseHook);
        g_mouseHook = NULL;
    }
}

HWND WindowCapture::SelectGameWindow() {
    std::cout << "请拖拽选择扫雷游戏窗口..." << std::endl;
    
    // 设置鼠标钩子
    g_mouseHook = SetWindowsHookEx(WH_MOUSE_LL, MouseHookProc, NULL, 0);
    if (!g_mouseHook) {
        std::cerr << "无法设置鼠标钩子" << std::endl;
        return NULL;
    }
    
    // 等待选择完成
    g_isSelecting = true;
    while (g_isSelecting) {
        MSG msg;
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
        Sleep(10);
    }
    
    // 查找包含选择矩形的窗口
    POINT center;
    center.x = (g_selectionRect.left + g_selectionRect.right) / 2;
    center.y = (g_selectionRect.top + g_selectionRect.bottom) / 2;
    
    HWND selectedHwnd = WindowFromPoint(center);
    if (selectedHwnd) {
        // 获取顶级父窗口
        m_gameHwnd = GetAncestor(selectedHwnd, GA_ROOT);
        std::cout << "已选择窗口: " << m_gameHwnd << std::endl;
        return m_gameHwnd;
    }
    
    return NULL;
}

bool WindowCapture::CaptureGameArea(cv::Mat& output) {
    if (!m_gameHwnd) return false;
    
    RECT rect;
    GetClientRect(m_gameHwnd, &rect);
    
    int width = rect.right - rect.left;
    int height = rect.bottom - rect.top;
    
    HDC hdcScreen = GetDC(NULL);
    HDC hdc = CreateCompatibleDC(hdcScreen);
    HBITMAP hBitmap = CreateCompatibleBitmap(hdcScreen, width, height);
    SelectObject(hdc, hBitmap);
    
    // 打印窗口到内存DC
    PrintWindow(m_gameHwnd, hdc, PW_CLIENTONLY);
    
    BITMAPINFOHEADER bi;
    bi.biSize = sizeof(BITMAPINFOHEADER);
    bi.biWidth = width;
    bi.biHeight = -height;  // 从上到下的位图
    bi.biPlanes = 1;
    bi.biBitCount = 32;
    bi.biCompression = BI_RGB;
    bi.biSizeImage = 0;
    bi.biXPelsPerMeter = 0;
    bi.biYPelsPerMeter = 0;
    bi.biClrUsed = 0;
    bi.biClrImportant = 0;
    
    output.create(height, width, CV_8UC4);
    GetDIBits(hdc, hBitmap, 0, height, output.data, (BITMAPINFO*)&bi, DIB_RGB_COLORS);
    
    DeleteObject(hBitmap);
    DeleteDC(hdc);
    ReleaseDC(NULL, hdcScreen);
    
    return true;
}

// 其他方法实现略...
```

### GameAnalyzer.h
```cpp
#ifndef GAME_ANALYZER_H
#define GAME_ANALYZER_H

#include <windows.h>
#include <opencv2/opencv.hpp>
#include <vector>

struct GameState {
    int rows;
    int cols;
    int mineCount;
    std::vector<std::vector<int>> grid; // -1:地雷, 0-8:数字, 9:未打开, 10:旗子
    int remainingMines;
    float exploredPercent;
};

class GameAnalyzer {
public:
    GameAnalyzer();
    
    bool AnalyzeGameState(const cv::Mat& gameImage, GameState& state);
    std::vector<cv::Point> FindSafeMoves(const GameState& state);
    void PerformClick(HWND hwnd, int x, int y, bool rightClick = false);
    
private:
    int RecognizeCell(const cv::Mat& cellImage);
    void LoadTemplates();
    
    std::vector<cv::Mat> m_numberTemplates;
};

#endif
```

### DisplayWindow.h
```cpp
#ifndef DISPLAY_WINDOW_H
#define DISPLAY_WINDOW_H

#include <windows.h>
#include <string>
#include "GameState.h"

class DisplayWindow {
public:
    DisplayWindow();
    ~DisplayWindow();
    
    bool Create();
    void Update(const GameState& state);
    void Render();
    
    HWND GetHandle() const { return m_hwnd; }
    
private:
    HWND m_hwnd;
    HDC m_memoryDC;
    HBITMAP m_bitmap;
    int m_width, m_height;
    GameState m_state;
    
    static LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
};

#endif
```

### main.cpp
```cpp
#include "WindowCapture.h"
#include "GameAnalyzer.h"
#include "DisplayWindow.h"
#include <thread>
#include <atomic>
#include <iostream>

std::atomic<bool> g_running(false);

void CaptureThread(WindowCapture& capture, cv::Mat& gameImage, std::mutex& imageMutex) {
    while (g_running) {
        cv::Mat frame;
        if (capture.CaptureGameArea(frame)) {
            std::lock_guard<std::mutex> lock(imageMutex);
            gameImage = frame.clone();
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}

void AnalysisThread(WindowCapture& capture, GameAnalyzer& analyzer, 
                   DisplayWindow& display, cv::Mat& gameImage, std::mutex& imageMutex) {
    GameState state;
    state.rows = 16; // 默认值，实际应从游戏识别
    state.cols = 16;
    state.mineCount = 40;
    
    while (g_running) {
        cv::Mat currentImage;
        {
            std::lock_guard<std::mutex> lock(imageMutex);
            if (!gameImage.empty()) {
                currentImage = gameImage.clone();
            }
        }
        
        if (!currentImage.empty()) {
            if (analyzer.AnalyzeGameState(currentImage, state)) {
                display.Update(state);
                
                auto safeMoves = analyzer.FindSafeMoves(state);
                for (const auto& move : safeMoves) {
                    int x = move.x * (currentImage.cols / state.cols) + (currentImage.cols / state.cols) / 2;
                    int y = move.y * (currentImage.rows / state.rows) + (currentImage.rows / state.rows) / 2;
                    analyzer.PerformClick(capture.GetGameWindow(), x, y);
                }
            }
        }
        
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
    }
}

int main() {
    WindowCapture capture;
    GameAnalyzer analyzer;
    DisplayWindow display;
    
    // 选择游戏窗口
    HWND gameHwnd = capture.SelectGameWindow();
    if (!gameHwnd) {
        std::cerr << "未能选择游戏窗口" << std::endl;
        return 1;
    }
    capture.SetGameWindow(gameHwnd);
    
    // 创建显示窗口
    if (!display.Create()) {
        std::cerr << "未能创建显示窗口" << std::endl;
        return 1;
    }
    
    // 启动线程
    cv::Mat gameImage;
    std::mutex imageMutex;
    
    g_running = true;
    std::thread captureThread(CaptureThread, std::ref(capture), std::ref(gameImage), std::ref(imageMutex));
    std::thread analysisThread(AnalysisThread, std::ref(capture), std::ref(analyzer), 
                              std::ref(display), std::ref(gameImage), std::ref(imageMutex));
    
    // 消息循环
    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    
    // 清理
    g_running = false;
    captureThread.join();
    analysisThread.join();
    
    return 0;
}
```

## 构建和运行

### 1. 配置VSCode
在项目根目录创建`.vscode/settings.json`:
```json
{
    "cmake.configureSettings": {
        "CMAKE_MAKE_PROGRAM": "mingw32-make.exe",
        "CMAKE_C_COMPILER": "gcc.exe",
        "CMAKE_CXX_COMPILER": "g++.exe"
    },
    "cmake.generator": "MSYS Makefiles",
    "cmake.buildDirectory": "${workspaceFolder}/build"
}
```

### 2. 构建项目
```bash
# 在VSCode中打开终端，切换到项目目录
mkdir -p build
cd build
cmake -G "MSYS Makefiles" ..
make
```

### 3. 运行应用
```bash
# 在build目录中
./bin/MinesweeperAssistant.exe
```

## 部署方案

### 1. 打包依赖
创建打包脚本`package.sh`:
```bash
#!/bin/bash
# 打包脚本
mkdir -p dist/MinesweeperAssistant
cp bin/MinesweeperAssistant.exe dist/MinesweeperAssistant/
cp /mingw64/bin/libopencv_*.dll dist/MinesweeperAssistant/
cp /mingw64/bin/libgcc_s_seh-1.dll dist/MinesweeperAssistant/
cp /mingw64/bin/libstdc++-6.dll dist/MinesweeperAssistant/
cp /mingw64/bin/libwinpthread-1.dll dist/MinesweeperAssistant/

# 创建启动脚本
echo "@echo off" > dist/MinesweeperAssistant/start.bat
echo "MinesweeperAssistant.exe" >> dist/MinesweeperAssistant/start.bat

# 打包成ZIP
cd dist
zip -r MinesweeperAssistant.zip MinesweeperAssistant/
cd ..
```

### 2. 创建安装指南
创建`README.md`文件:
```
# 扫雷助手使用指南

## 系统要求
- Windows 10/11
- 已安装扫雷游戏

## 安装步骤
1. 下载MinesweeperAssistant.zip并解压
2. 运行start.bat启动程序
3. 按照提示选择扫雷游戏窗口
4. 程序将自动分析并辅助完成游戏

## 注意事项
- 确保扫雷游戏窗口可见且未被遮挡
- 程序运行期间不要移动扫雷窗口
```

## 总结

这个扫雷助手应用使用了MSYS2作为开发环境，CMake作为构建系统，OpenCV进行图像处理，Windows API进行窗口操作。通过多线程架构实现了实时捕获、分析和显示功能。

应用的核心在于图像识别和扫雷算法的实现，需要针对不同版本的扫雷游戏调整识别参数。实际部署时，需要打包所有依赖的DLL文件以确保在没有开发环境的计算机上正常运行。